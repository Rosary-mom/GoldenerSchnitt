import matplotlib.pyplot as plt
import numpy as np

def lucas(n):
    if n == 0: return 2
    if n == 1: return 1
    return lucas(n-1) + lucas(n-2)

# Erweiterte Spirale
theta = np.linspace(0, 4*np.pi, 1000)
r_fib = np.exp(theta * np.log(1.618) / (2*np.pi))  # Fibonacci/Phi
r_luc = r_fib * (lucas(5) / 5)  # Erweitert mit Lucas
plt.polar(theta, r_fib, 'g-', label='Fibonacci')
plt.polar(theta, r_luc, 'r-', label='Lucas-Erweiterung')
plt.legend()
plt.show()
import matplotlib.pyplot as plt
import numpy as np

# Q-Key Approximation f端r Phi (vereinfacht, erweitere mit deiner 420-stelligen Primzahl Q)
phi_approx = (1 + np.sqrt(5)) / 2  # Basis-Phi; f端r Q: nutze modulare Arithmetik

# Funktion f端r Golden Spiral
def golden_spiral(ax, turns=4, a=0.1):
    theta = np.linspace(0, turns * 2 * np.pi, 1000)
    r = a * np.exp(theta * np.log(phi_approx))
    ax.plot(theta, r, 'g-', label='Goldene Spirale (Fibonacci)')

# Chartres
fig, ax = plt.subplots(subplot_kw={'projection': 'polar'})
golden_spiral(ax)
ax.set_title('Generiertes Chartres-Labyrinth')
plt.savefig('chartres_labyrinth_generated.png')
plt.close(fig)

# Bonn mit Wasser-Pfad (Abzweigung)
fig, ax = plt.subplots(subplot_kw={'projection': 'polar'})
golden_spiral(ax)
r_water = 0.8 * a * np.exp(theta * np.log(phi_approx))  # Abzweigung
ax.plot(theta, r_water, 'b--', label='Wasserf端hrender Pfad')
ax.set_title('Generiertes Bonn-Brunnen-Labyrinth')
plt.savefig('bonn_labyrinth_brunnen_generated.png')
plt.close(fig)
