<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <title>ROSARY RIDGEBED • 7 Gaben des Hl. Geistes – Goldener Weg</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.jsdelivr.net/npm/three@0.167.1/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.167.1/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.167.1/examples/js/exporters/STLExporter.js"></script>
  <style>
    body { margin:0; overflow:hidden; background:radial-gradient(circle at center,#0b1a33 0%,#000 100%); color:#fff; font-family:Arial,sans-serif; }
    #info,#controls{position:absolute;padding:15px;border-radius:12px;backdrop-filter:blur(12px);background:rgba(0,0,0,0.7);border:1px solid rgba(212,175,55,0.5);z-index:10;box-shadow:0 0 20px rgba(212,175,55,0.3);}
    #info{top:10px;left:10px;max-width:420px;}
    #controls{bottom:20px;left:20px;}
    button{padding:10px 20px;margin:5px;background:linear-gradient(45deg,#d4af37,#ffd700);border:none;border-radius:8px;cursor:pointer;font-weight:bold;color:#000;transition:0.2s;}
    button:hover{transform:scale(1.05);}
    #modal{display:none;position:fixed;inset:0;background:rgba(0,0,0,0.9);z-index:100;justify-content:center;align-items:center;backdrop-filter:blur(8px);}
    #modal-content{background:#111;padding:40px;border-radius:15px;border:2px solid #d4af37;max-width:600px;text-align:center;}
    .close{position:absolute;top:10px;right:20px;font-size:36px;cursor:pointer;color:#d4af37;}
  </style>
</head>
<body>
<div id="canvas-container"></div>

<div id="info">
  <h1 style="margin:0;color:#d4af37;text-shadow:0 0 10px gold">7 Gaben des Hl. Geistes – Goldener Weg</h1>
  <button onclick="toggleView()">Modus: Laien ↔ Forscher</button>
  <div id="laien"><p><b>Prinzip:</b> Hügel wächst spiralförmig (Fibonacci). Jede Schicht = eine Gabe.</p></div>
  <div id="forscher" style="display:none"><p>Rosenkranz-Approximation n=17→153<br>Skaleninvarianz S(r)=k·r^φ</p></div>
</div>

<div id="controls">
  <button onclick="resetCamera()">Ansicht zurück</button>
  <button onclick="toggleRotation()">Rotation an/aus</button>
  <button onclick="exportSTL()">3D-Druck STL</button>
</div>

<div id="modal" onclick="closeModal()">
  <div id="modal-content" onclick="event.stopPropagation()">
    <span class="close" onclick="closeModal()">×</span>
    <h2 id="modal-title" style="color:#ffd700"></h2>
    <hr style="border-color:#444">
    <p id="modal-psalm"></p>
    <p id="modal-denk" style="color:#d4af37;font-style:italic"></p>
  </div>
</div>

<script>
// Setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x001133);
scene.fog = new THREE.FogExp2(0x001133, 0.012);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(12, 14, 20);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
document.getElementById('canvas-container').appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.autoRotate = true;
controls.autoRotateSpeed = 0.5;

// Licht
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const sun = new THREE.DirectionalLight(0xfffaed, 4);
sun.position.set(20, 50, 20);
sun.castShadow = true;
sun.shadow.mapSize.width = 2048;
sun.shadow.mapSize.height = 2048;
scene.add(sun);
scene.add(new THREE.PointLight(0xffd700, 6, 40).setPosition(0,12,0));

// Gras-Textur (kein CORS)
function grass() {
  const c = document.createElement('canvas');
  c.width = c.height = 512;
  const ctx = c.getContext('2d');
  ctx.fillStyle = '#1a3a0b';
  ctx.fillRect(0,0,512,512);
  for(let i=0;i<8000;i++){
    ctx.fillStyle = Math.random()>0.5?'#2a5a1b':'#3a7a2b';
    ctx.fillRect(Math.random()*512,Math.random()*512,2+Math.random()*4,2+Math.random()*6);
  }
  const tex = new THREE.CanvasTexture(c);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.repeat.set(10,10);
  return tex;
}
const grassTex = grass();

// 7 Terrassen
const colors = [0x5c4033,0x6b4630,0x5d4037,0x4a3728,0x3e2b1f,0x2b1e16,0x228b22];
const gaben = ["Furcht des Herrn","Frömmigkeit","Erkenntnis","Stärke","Rat","Verstand","Weisheit"];
const terraces = [];

for(let i=0;i<7;i++){
  const h = 2.8;
  const rTop = 10 - i*1.1;
  const rBot = 10 - (i-1)*1.1;
  const geo = new THREE.CylinderGeometry(i===6?rTop-0.5:rTop, rBot, h, 80, 1, false);
  const mat = i===6 ? new THREE.MeshStandardMaterial({map:grassTex, bumpMap:grassTex, bumpScale:0.4, roughness:0.85})
                    : new THREE.MeshStandardMaterial({color:colors[i], roughness:0.9, metalness:0.05});
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.y = -10 + i*h + h/2;
  mesh.castShadow = mesh.receiveShadow = true;
  mesh.userData.index = i;
  scene.add(mesh);
  terraces.push(mesh);
}

// Goldene Spirale
const points = [];
let r=0.3, a=0, y=-10;
for(let i=0;i<1600;i++){
  points.push(new THREE.Vector3(r*Math.cos(a), y, r*Math.sin(a)));
  a += 0.13;
  r += 0.0085;
  if(i%120===0) y += 0.75;
}
const spiral = new THREE.Mesh(
  new THREE.TubeGeometry(new THREE.CatmullRomCurve3(points), 1600, 0.28, 16, false),
  new THREE.MeshPhysicalMaterial({color:0xffd700, metalness:1, roughness:0.1, emissive:0xaa8800, emissiveIntensity:0.8})
);
spiral.castShadow = true;
scene.add(spiral);

// Pyramide + Salomonssiegel oben
const pyramid = new THREE.Mesh(
  new THREE.ConeGeometry(2, 5, 6),
  new THREE.MeshPhysicalMaterial({color:0xffd700, metalness:1, roughness:0.05, clearcoat:1})
);
pyramid.position.y = 10.5;
pyramid.castShadow = true;
scene.add(pyramid);

const starShape = new THREE.Shape();
for(let i=0;i<12;i++){
  const ang = i/6*Math.PI;
  const rad = i%2===0?2:1;
  i===0?starShape.moveTo(rad*Math.cos(ang),rad*Math.sin(ang)):starShape.lineTo(rad*Math.cos(ang),rad*Math.sin(ang));
}
const star = new THREE.Mesh(
  new THREE.ExtrudeGeometry(starShape,{depth:0.5,bevelEnabled:true,bevelThickness:0.2}),
  new THREE.MeshPhysicalMaterial({color:0xffd700, metalness:1, roughness:0.05})
);
star.rotation.x = -Math.PI/2;
star.position.y = 13.8;
star.castShadow = true;
scene.add(star);

// Modal-Daten
const data = [
  {psalm:"Psalm 111", text:"Die Furcht des Herrn ist der Weisheit Anfang.", denk:"Fundament-Gesetz"},
  {psalm:"Psalm 120", text:"In meiner Not rief ich zum Herrn …", denk:"Kingfisher-Gesetz"},
  {psalm:"Psalm 122", text:"Freut euch mit Jerusalem …", denk:"DiaKonos-Gesetz"},
  {psalm:"Psalm 124", text:"Wäre der Herr nicht bei uns …", denk:"Skaleninvarianz"},
  {psalm:"Psalm 126", text:"Die mit Tränen säen …", denk:"Hebel-Gesetz"},
  {psalm:"Psalm 130", text:"Aus den Tiefen rufe ich …", denk:"Coan-Paradoxon"},
  {psalm:"Psalm 134", text:"Segnet den Herrn, alle Diener des Herrn …", denk:"Heureka – Vollendung"}
];

// Raycaster
const ray = new THREE.Raycaster();
const mouse = new THREE.Vector2();
window.addEventListener('click', e=>{
  mouse.x = (e.clientX/innerWidth)*2-1;
  mouse.y = -(e.clientY/innerHeight)*2+1;
  ray.setFromCamera(mouse,camera);
  const hits = ray.intersectObjects(terraces);
  if(hits.length){
    const i = hits[0].object.userData.index;
    document.getElementById('modal-title').textContent = gaben[i];
    document.getElementById('modal-psalm').textContent = data[i].psalm + ": " + data[i].text;
    document.getElementById('modal-denk').textContent = "Denkgesetz: " + data[i].denk;
    document.getElementById('modal').style.display = 'flex';
    controls.autoRotate = false;
  }
});

// Funktionen
function exportSTL(){
  const exporter = new THREE.STLExporter();
  const result = exporter.parse(scene);
  const blob = new Blob([result], {type: 'text/plain'});
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = 'rosary-7gaben-huegel.stl';
  link.click();
}
function toggleView(){
  const l = document.getElementById('laien');
  const f = document.getElementById('forscher');
  [l.style.display, f.style.display] = [f.style.display, l.style.display];
}
function resetCamera(){ camera.position.set(12,14,20); controls.target.set(0,3,0); controls.update(); }
function toggleRotation(){ controls.autoRotate = !controls.autoRotate; }
function closeModal(){ document.getElementById('modal').style.display='none'; controls.autoRotate=true; }

// Animate
function animate(){
  requestAnimationFrame(animate);
  star.rotation.y += 0.004;
  controls.update();
  renderer.render(scene,camera);
}
animate();

window.onresize = ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
};
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualisierungen der Pyramiden und Hügel mit Göttlichen Gaben</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f9f9f9; }
        .container { max-width: 1200px; margin: auto; }
        .placeholder { width: 100%; height: 300px; background-color: #fff000; color: white; text-align: center; padding-top: 100px; font-size: 24px; }
        canvas { border: 1px solid #ccc; width: 100%; max-width: 600px; height: 400px; }
        .buttons { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 20px; }
        button { padding: 10px 20px; background-color: 
#1d4ed8

; color: white; border: none; cursor: pointer; }
        button:hover { background-color: #0056b3; }
        .output { margin-top: 20px; padding: 10px; background-color: #fff; border: 1px solid #ddd; }
        .tooltip { position: relative; display: inline-block; }
        .tooltip .tooltiptext { visibility: hidden; width: 200px; background-color: #555; color: #fff; text-align: center; padding: 5px; position: absolute; z-index: 1; }
        .tooltip:hover .tooltiptext { visibility: visible; }
        @media (max-width: 768px) { .buttons { flex-direction: column; } } /* Responsivität */
    </style>
</head>
<body>
    <div class="container">
        <h1>Visualisierungen der Pyramiden und ROSARY©®™ - Hügel mit Göttlichen Gaben</h1>
        <p>Diese App integriert Goldenen Schnitt, Fibonacci-Lucas-Folgen und Rosencrantz-Approximation mit Q-Key für präzise Berechnungen. Gamifiziert als Labyrinth-Prozession für spirituelles Wachstum – siehe Blog-Beitrag zu öttlichen Gaben.</p>

        <<a href="http://creativecommons.org/licenses/by-sa/3.0/" title="Creative Commons Attribution-Share Alike 3.0">CC BY-SA 3.0</a>, <a href="https://commons.wikimedia.org/w/index.php?curid=510275">Link</a>>Chartres Labyrinth mit Gaben</a>
        <<a href="https://creativecommons.org/licenses/by/4.0/" title="Creative Commons Namensnennung">CC BY 4.0</a>, <a href="https://bonn.wiki/index.php?curid=5785">Link</a>>Bonn Brunner-Labyrinth</a>

        <div id="visualization" class="placeholder">Hügel mit Labyrinth</div> <!-- Wird durch Canvas ersetzt -->
        <canvas id="labyrinthCanvas" style="display: none;"></canvas> <!-- Für dynamische Zeichnungen -->

        <h2>Dynamische Erweiterungen (Gamifiziert)</h2>
        <p>Kick für Simulation – Sammle Punkte durch Gaben-Sammeln.</p>
        <div class="buttons">
            <button onclick="extendModel()" class="tooltip">Erweitere Model (Lucas-Folge)<span class="tooltiptext">Erweitert das Modell basierend auf Lucas-Folgen für spirituelles Wachstum.</span></button>
            <button onclick="simulateEvent()" class="tooltip">Simuliere Zufallsevent (Hybrides)<span class="tooltiptext">Simuliert hybride Ereignisse mit Zufallselementen und Goldenem Schnitt.</span></button>
            <button onclick="liturgicalPath()" class="tooltip">Liturgischer Weg (Abzweigungen)<span class="tooltiptext">Generiert Pfade mit Abzweigungen für liturgische Prozessionen.</span></button>
            <button onclick="downloadSVG()">Download SVG (Plotter)</button>
            <button onclick="downloadSTL()">Download STL (3D-Printer)</button>
        </div>

        <div id="output" class="output"></div>
    </div>

    <script src="script.js"></script> <!-- Hier wird die externe JS-Datei hinzugefügt -->
</body>
</html>
  <!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <title>Test Dark Mode</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    body { 
      margin: 40px; 
      font-family: 'Inter', sans-serif; 
      background: linear-gradient(135deg, #0d1117 0%, #161b22 100%);
      color: #e6edf3; 
      line-height: 1.6;
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><filter id="n"><feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="4" stitchTiles="stitch"/><feColorMatrix type="saturate" values="0"/></filter><rect width="100" height="100" filter="url(%23n)" opacity="0.03"/></svg>');
    }
    .card { background: rgba(255,255,255,0.05); padding: 20px; border-radius: 12px; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1); }
  </style>
</head>
<body>
  <div class="card">
    <h1>Das sieht jetzt viel besser aus!</h1>
    <p>Weicher Hintergrund, angenehmer Text, subtile Noise-Texture – 2025-ready.</p>
  </div>
</body>
</html>        
<html>
<head>
<title>Golden Ratio Pyramid Labyrinth Simulation</title>
<style>body{background:#111;color:#fff;}#score{font-size:20px;}</style>
</head>
<body>
<h1>Gamified Labyrinth Navigation</h1>
<p>Navigate fluorescent particle through golden ratio pyramid labyrinth with spiral paths in Swabian Alb caves. Use arrows to move. Collect points by reaching end.</p>
<canvas id="canvas" width="800" height="600" style="border:1px solid #fff;"></canvas>
<div id="score">Score: 0 | Level: 1</div>
<button onclick="resetLevel()">Next Level</button>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let player = {x: 50, y: 300, vx: 0, vy: 0};
let particles = []; // Trail particles
let score = 0;
let level = 1;
const phi = (1 + Math.sqrt(5)) / 2; // Golden ratio
const b = Math.log(phi) / (Math.PI / 2); // For golden spiral

// Generate labyrinth with golden ratio pyramids and spirals
const walls = [];
function generateLabyrinth() {
  walls.length = 0;
  // Pyramid structures
  for (let i = 0; i < 5; i++) {
    let base = 50 * phi;
    let height = base / phi;
    let x = 100 + i * 150;
    walls.push({x: x, y: 200, w: base, h: height, type: 'up'}); // Top pyramid (pointing up)
    walls.push({x: x, y: 400 - height, w: base, h: height, type: 'down'}); // Bottom (pointing down)
  }
  // Labyrinth paths
  walls.push({x: 0, y: 0, w: 800, h: 50, type: 'rect'}); // Top wall
  walls.push({x: 0, y: 550, w: 800, h: 50, type: 'rect'}); // Bottom wall
  
  // Add spiral path element
  let cx = 400, cy = 300;
  let a = 10; // Initial radius
  let maxTheta = 4 * Math.PI;
  let spiralWall = {type: 'spiral', cx, cy, a, b, maxTheta, segments: []};
  for (let theta = 0; theta <= maxTheta; theta += 0.2) {
    let r = a * Math.exp(b * theta);
    let x = cx + r * Math.cos(theta);
    let y = cy + r * Math.sin(theta);
    spiralWall.segments.push({x, y, r: 5});
  }
  walls.push(spiralWall);
}

// Draw labyrinth
function drawLabyrinth() {
  ctx.clearRect(0,0,800,600);
  ctx.fillStyle = '#111';
  ctx.fillRect(0,0,800,600);
  ctx.fillStyle = '#444';
  ctx.strokeStyle = '#fff';
  walls.forEach(w => {
    if (w.type === 'rect') {
      ctx.fillRect(w.x, w.y, w.w, w.h);
    } else if (w.type === 'up') {
      ctx.beginPath();
      ctx.moveTo(w.x, w.y + w.h);
      ctx.lineTo(w.x + w.w / 2, w.y);
      ctx.lineTo(w.x + w.w, w.y + w.h);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    } else if (w.type === 'down') {
      ctx.beginPath();
      ctx.moveTo(w.x, w.y);
      ctx.lineTo(w.x + w.w / 2, w.y + w.h);
      ctx.lineTo(w.x + w.w, w.y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    } else if (w.type === 'spiral') {
      ctx.beginPath();
      let theta = 0;
      let r = w.a * Math.exp(w.b * theta);
      let x = w.cx + r * Math.cos(theta);
      let y = w.cy + r * Math.sin(theta);
      ctx.moveTo(x, y);
      for (theta = 0.1; theta <= w.maxTheta; theta += 0.1) {
        r = w.a * Math.exp(w.b * theta);
        x = w.cx + r * Math.cos(theta);
        y = w.cy + r * Math.sin(theta);
        ctx.lineTo(x, y);
      }
      ctx.lineWidth = 3;
      ctx.stroke();
      ctx.lineWidth = 1;
    }
  });
}

// Enhanced fluorescent particle
class Particle {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.color = `hsl(${Math.random()*60+180},100%,50%)`;
    this.alpha = 1;
  }
  update() {
    this.alpha -= 0.01; // Slower fade for better trail
    return this.alpha > 0;
  }
  draw() {
    ctx.shadowColor = this.color;
    ctx.shadowBlur = 15; // Enhanced glow
    ctx.beginPath();
    ctx.arc(this.x, this.y, 5, 0, Math.PI*2);
    ctx.fillStyle = this.color;
    ctx.globalAlpha = this.alpha;
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;
  }
}

// Draw player with glow
function drawPlayer() {
  ctx.shadowColor = 'lime';
  ctx.shadowBlur = 25; // Enhanced
  ctx.beginPath();
  ctx.arc(player.x, player.y, 10, 0, Math.PI*2);
  ctx.fillStyle = 'lime';
  ctx.fill();
  ctx.shadowBlur = 0;
}

// Improved triangle collision detection
function pointInTriangle(px, py, x1, y1, x2, y2, x3, y3) {
  const area = 0.5 * (-y2*x3 + y1*(-x2 + x3) + x1*(y2 - y3) + x2*y3 - x3*y2);
  const s = 1/(2*area)*(y1*x3 - x1*y3 + px*(y3 - y1) + x3*(y1 - py) + x1*(py - y3));
  const t = 1/(2*area)*(x1*y2 - y1*x2 + py*(x1 - x2) + y2*(px - x1) + x2*(y1 - py));
  return s > 0 && t > 0 && (1 - s - t) > 0;
}

function checkCollision(nx, ny) {
  for (let wall of walls) {
    if (wall.type === 'rect') {
      if (nx + 10 > wall.x && nx - 10 < wall.x + wall.w && ny + 10 > wall.y && ny - 10 < wall.y + wall.h) {
        return true;
      }
    } else if (wall.type === 'up') {
      const x1 = wall.x, y1 = wall.y + wall.h;
      const x2 = wall.x + wall.w / 2, y2 = wall.y;
      const x3 = wall.x + wall.w, y3 = wall.y + wall.h;
      if (pointInTriangle(nx, ny, x1, y1, x2, y2, x3, y3)) return true;
    } else if (wall.type === 'down') {
      const x1 = wall.x, y1 = wall.y;
      const x2 = wall.x + wall.w / 2, y2 = wall.y + wall.h;
      const x3 = wall.x + wall.w, y3 = wall.y;
      if (pointInTriangle(nx, ny, x1, y1, x2, y2, x3, y3)) return true;
    } else if (wall.type === 'spiral') {
      for (let seg of wall.segments) {
        let dx = nx - seg.x;
        let dy = ny - seg.y;
        if (Math.sqrt(dx*dx + dy*dy) < 10 + seg.r) return true;
      }
    }
  }
  return false;
}

// Animation loop
function animate() {
  drawLabyrinth();
  drawPlayer();
  particles = particles.filter(p => p.update());
  particles.forEach(p => p.draw());

  // Update player
  let nx = player.x + player.vx;
  let ny = player.y + player.vy;
  if (!checkCollision(nx, ny)) {
    player.x = nx;
    player.y = ny;
  }
  if (Math.abs(player.vx) > 0 || Math.abs(player.vy) > 0) {
    particles.push(new Particle(player.x, player.y)); // Add trail only when moving
  }

  if (player.x > 750) {
    score += 100 * level;
    document.getElementById('score').textContent = `Score: ${score} | Level: ${level}`;
    resetLevel();
  }

  requestAnimationFrame(animate);
}

// Controls
document.addEventListener('keydown', e => {
  switch (e.key) {
    case 'ArrowUp': player.vy = -2; break;
    case 'ArrowDown': player.vy = 2; break;
    case 'ArrowLeft': player.vx = -2; break;
    case 'ArrowRight': player.vx = 2; break;
  }
});
document.addEventListener('keyup', e => {
  switch (e.key) {
    case 'ArrowUp':
    case 'ArrowDown': player.vy = 0; break;
    case 'ArrowLeft':
    case 'ArrowRight': player.vx = 0; break;
  }
});

// Reset for next level
function resetLevel() {
  level++;
  player.x = 50;
  player.y = 300;
  particles = [];
  generateLabyrinth();
}

generateLabyrinth();
animate();
</script>
</body>
</html>
