<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <title>ROSARY RIDGEBED ‚Ä¢ 7 Gaben H√ºgelbeet Pyramide</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.jsdelivr.net/npm/three@0.167.1/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.167.1/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.167.1/examples/js/exporters/STLExporter.js"></script>
  <style>
    body{margin:0;overflow:hidden;background:#001133;color:#fff;font-family:Arial}
    #info,#controls{position:absolute;padding:20px;border-radius:12px;backdrop-filter:blur(12px);border:1px solid rgba(212,175,55,0.5);background:rgba(0,0,0,0.7);z-index:10}
    #info{top:10px;left:10px;max-width:420px}
    #controls{bottom:20px;left:20px}
    button{padding:10px 20px;margin:5px;background:linear-gradient(45deg,#d4af37,#ffd700);border:none;border-radius:8px;cursor:pointer;font-weight:bold;color:#000;box-shadow:0 4px 10px rgba(0,0,0,0.5)}
    #modal{display:none;position:fixed;inset:0;background:rgba(0,0,0,0.95);z-index:100;justify-content:center;align-items:center}
    #modal-content{background:#111;padding:35px;border-radius:15px;border:3px solid #d4af37;max-width:650px;text-align:center}
    .close{float:right;font-size:32px;cursor:pointer;color:#d4af37}
  </style>
</head>
<body>
<div id="canvas-container"></div>

<div id="info">
  <h1 style="margin:0;color:#d4af37;text-shadow:0 0 15px gold">7 Gaben des Hl. Geistes ‚Äì Goldener Weg</h1>
  <button onclick="toggleView()">Laien ‚Üî Forscher Modus</button>
  <div id="laien"><p style="line-height:1.6"><b>Eselsbr√ºcke:</b> Der H√ºgel w√§chst wie eine Schnecke üêå ‚Äì jede Windung gr√∂√üer (Fibonacci). Jede Schicht ist eine Gabe ‚Äì von der Demut unten bis zur Weisheit oben.</p></div>
  <div id="forscher" style="display:none"><p style="line-height:1.6"><b>Rosenkranz-Approximation n=17 ‚Üí 153</b><br>h ‚âà Œ£ binom(17,k) (1/œÜ)^k ¬∑ h^(k)(Q)<br>Skaleninvarianz: S(r) = k ¬∑ r^œÜ</p></div>
</div>

<div id="controls">
  <button onclick="camera.position.set(10,10,15);controls.reset()">Ansicht zur√ºck</button>
  <button onclick="isRotating=!isRotating">Rotation an/aus</button>
  <button onclick="exportSTL()">3D-Druck STL</button>
</div>

<div id="modal" onclick="this.style.display='none'">
  <div id="modal-content" onclick="event.stopPropagation()">
    <span class="close">√ó</span>
    <h2 id="modal-title" style="color:#d4af37"></h2>
    <p id="modal-psalm"></p>
    <p id="modal-denk" style="color:#d4af37;font-style:italic;"></p>
  </div>
</div>

<script>
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x001133);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(10,10,15);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.getElementById('canvas-container').appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

let isRotating = true;
const terraces = [];

// Gras-Textur (wird asynchron geladen ‚Äì fallback farbe)
const loader = new THREE.TextureLoader();
let grass;
loader.load('https://i.imgur.com/4tZEm8T.jpeg', texture => {
  grass = texture;
  grass.wrapS = grass.wrapT = THREE.RepeatWrapping;
  grass.repeat.set(12,12);
  // neu rendern wenn Textur geladen
  renderer.render(scene, camera);
});

// 7 Schichten H√ºgelbeet
const colors = [0x8b4513,0x8b5a2b,0x228b22,0x654321,0x4b3621,0x5d4037,0x228b22];
const gaben = ["Furcht des Herrn","Fr√∂mmigkeit","Erkenntnis","St√§rke","Rat","Verstand","Weisheit"];
for(let i=0;i<7;i++){
  const h = (i+1)/8*16;
  const r = 9*(1-i/8);
  const geo = new THREE.CylinderGeometry(r, r+1.2, 2.5, 64,1,true);
  const mat = new THREE.MeshPhongMaterial({
    color: colors[i],
    map: i===6 && grass ? grass : null,
    bumpMap: grass || null,
    bumpScale: 0.7,
    shininess: 40
  });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.y = -8 + h;
  scene.add(mesh);
  terraces.push(mesh);
}

// Goldene Spirale
const points = [];
let radius = 0.3, angle = 0, y = -8;
for(let i=0;i<1400;i++){
  points.push(new THREE.Vector3(radius*Math.cos(angle), y, radius*Math.sin(angle)));
  angle += 0.13;
  radius += 0.009;
  if(i%100===0) y += 0.9;
}
const curve = new THREE.CatmullRomCurve3(points);
const tubeGeo = new THREE.TubeGeometry(curve,1400,0.25,16,false);
const tubeMat = new THREE.MeshPhongMaterial({color:0xffd700,emissive:0xaa8800,shininess:150});
const spiral = new THREE.Mesh(tubeGeo, tubeMat);
scene.add(spiral);

// Salomonisches Siegel + Pyramide oben
const starShape = new THREE.Shape();
const outer = 1.5, inner = 0.75;
for(let i=0;i<12;i++){
  const a = i/6*Math.PI;
  const r = i%2===0 ? outer : inner;
  i===0 ? starShape.moveTo(r*Math.sin(a),r*Math.cos(a)) : starShape.lineTo(r*Math.sin(a),r*Math.cos(a));
}
starShape.closePath();
const starGeo = new THREE.ExtrudeGeometry(starShape,{depth:0.4,bevelEnabled:true});
const starMat = new THREE.MeshPhongMaterial({color:0xffd700,emissive:0xaa8800});
const star = new THREE.Mesh(starGeo, starMat);
star.rotation.x = -Math.PI/2;
star.position.set(0,10.6,0);
scene.add(star);

const pyramid = new THREE.Mesh(new THREE.ConeGeometry(1.9,4.2,6), starMat);
pyramid.position.y = 9.9;
scene.add(pyramid);

// LICHT ‚Äì jetzt wirklich hell!
scene.add(new THREE.AmbientLight(0xffffff, 5));
const sun = new THREE.DirectionalLight(0xfff8e1, 12);
sun.position.set(15,40,15);
scene.add(sun);
scene.add(new THREE.PointLight(0xffd700, 10, 100));
scene.add(new THREE.HemisphereLight(0x87ceeb, 0x228b22, 6));

// Modal-Daten
const data = [
  {psalm:"Psalm 120", text:"In meiner Not rief ich zum Herrn ‚Ä¶", denk:"Kingfisher-Gesetz"},
  {psalm:"Psalm 122", text:"Freut euch mit mir ‚Ä¶", denk:"DiaKonos-Gesetz"},
  {psalm:"Psalm 124", text:"W√§re der Herr nicht bei uns ‚Ä¶", denk:"Skaleninvarianz"},
  {psalm:"Psalm 126", text:"Die mit Tr√§nen s√§en ‚Ä¶", denk:"Hebel-Gesetz"},
  {psalm:"Psalm 128", text:"Wohl dem, der den Herrn f√ºrchtet ‚Ä¶", denk:"Rosenkranz-Iteration"},
  {psalm:"Psalm 130", text:"Aus den Tiefen rufe ich ‚Ä¶", denk:"Coan-Paradoxon"},
  {psalm:"Psalm 134", text:"Segnet den Herrn ‚Ä¶", denk:"Heureka ‚Äì Vollendung"}
];

// Raycaster ‚Äì jetzt 100 % korrekt
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
window.addEventListener('click', e => {
  mouse.x = (e.clientX/window.innerWidth)*2-1;
  mouse.y = -(e.clientY/window.innerHeight)*2+1;
  raycaster.setFromCamera(mouse,camera);
  const hits = raycaster.intersectObjects(terraces);
  if(hits.length){
    const i = terraces.indexOf(hits[0].object);
    document.getElementById('modal-title').textContent = gaben[i];
    document.getElementById('modal-psalm').textContent = data[i].psalm + ": " + data[i].text;
    document.getElementById('modal-denk').textContent = "Denkgesetz: " + data[i].denk;
    document.getElementById('modal').style.display = 'flex';
  }
});

// Export + toggle + animate
function exportSTL(){
  const exporter = new THREE.STLExporter();
  const stl = exporter.parse(scene);
  const blob = new Blob([stl],{type:'text/plain'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'rosary_ridgebed.stl';
  a.click();
}

function toggleView(){
  const l = document.getElementById('laien');
  const f = document.getElementById('forscher');
  l.style.display = l.style.display==='none' ? 'block' : 'none';
  f.style.display = f.style.display==='none' ? 'block' : 'none';
}

function animate(){
  requestAnimationFrame(animate);
  if(isRotating) spiral.rotation.y += 0.002;
  controls.update();
  renderer.render(scene,camera);
}
animate();

window.onresize = () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
};
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualisierungen der Pyramiden und H√ºgel mit G√∂ttlichen Gaben</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f9f9f9; }
        .container { max-width: 1200px; margin: auto; }
        .placeholder { width: 100%; height: 300px; background-color: #ff0000; color: white; text-align: center; padding-top: 100px; font-size: 24px; }
        canvas { border: 1px solid #ccc; width: 100%; max-width: 600px; height: 400px; }
        .buttons { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 20px; }
        button { padding: 10px 20px; background-color: #007bff; color: white; border: none; cursor: pointer; }
        button:hover { background-color: #0056b3; }
        .output { margin-top: 20px; padding: 10px; background-color: #fff; border: 1px solid #ddd; }
        .tooltip { position: relative; display: inline-block; }
        .tooltip .tooltiptext { visibility: hidden; width: 200px; background-color: #555; color: #fff; text-align: center; padding: 5px; position: absolute; z-index: 1; }
        .tooltip:hover .tooltiptext { visibility: visible; }
        @media (max-width: 768px) { .buttons { flex-direction: column; } } /* Responsivit√§t */
    </style>
</head>
<body>
    <div class="container">
        <h1>Visualisierungen der Pyramiden und ROSARY¬©¬Æ‚Ñ¢ - H√ºgel mit G√∂ttlichen Gaben</h1>
        <p>Diese App integriert Goldenen Schnitt, Fibonacci-Lucas-Folgen und Rosencrantz-Approximation mit Q-Key f√ºr pr√§zise Berechnungen. Gamifiziert als Labyrinth-Prozession f√ºr spirituelles Wachstum ‚Äì siehe Blog-Beitrag zu √∂ttlichen Gaben.</p>

        <<a href="http://creativecommons.org/licenses/by-sa/3.0/" title="Creative Commons Attribution-Share Alike 3.0">CC BY-SA 3.0</a>, <a href="https://commons.wikimedia.org/w/index.php?curid=510275">Link</a>>Chartres Labyrinth mit Gaben</a>
        <<a href="https://creativecommons.org/licenses/by/4.0/" title="Creative Commons Namensnennung">CC BY 4.0</a>, <a href="https://bonn.wiki/index.php?curid=5785">Link</a>>Bonn Brunner-Labyrinth</a>

        <div id="visualization" class="placeholder">H√ºgel mit Labyrinth</div> <!-- Wird durch Canvas ersetzt -->
        <canvas id="labyrinthCanvas" style="display: none;"></canvas> <!-- F√ºr dynamische Zeichnungen -->

        <h2>Dynamische Erweiterungen (Gamifiziert)</h2>
        <p>Kick f√ºr Simulation ‚Äì Sammle Punkte durch Gaben-Sammeln.</p>
        <div class="buttons">
            <button onclick="extendModel()" class="tooltip">Erweitere Model (Lucas-Folge)<span class="tooltiptext">Erweitert das Modell basierend auf Lucas-Folgen f√ºr spirituelles Wachstum.</span></button>
            <button onclick="simulateEvent()" class="tooltip">Simuliere Zufallsevent (Hybrides)<span class="tooltiptext">Simuliert hybride Ereignisse mit Zufallselementen und Goldenem Schnitt.</span></button>
            <button onclick="liturgicalPath()" class="tooltip">Liturgischer Weg (Abzweigungen)<span class="tooltiptext">Generiert Pfade mit Abzweigungen f√ºr liturgische Prozessionen.</span></button>
            <button onclick="downloadSVG()">Download SVG (Plotter)</button>
            <button onclick="downloadSTL()">Download STL (3D-Printer)</button>
        </div>

        <div id="output" class="output"></div>
    </div>

    <script src="script.js"></script> <!-- Hier wird die externe JS-Datei hinzugef√ºgt -->
</body>
</html>
<html>
<head>
<title>Golden Ratio Pyramid Labyrinth Simulation</title>
<style>body{background:#111;color:#fff;}#score{font-size:20px;}</style>
</head>
<body>
<h1>Gamified Labyrinth Navigation</h1>
<p>Navigate fluorescent particle through golden ratio pyramid labyrinth with spiral paths in Swabian Alb caves. Use arrows to move. Collect points by reaching end.</p>
<canvas id="canvas" width="800" height="600" style="border:1px solid #fff;"></canvas>
<div id="score">Score: 0 | Level: 1</div>
<button onclick="resetLevel()">Next Level</button>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let player = {x: 50, y: 300, vx: 0, vy: 0};
let particles = []; // Trail particles
let score = 0;
let level = 1;
const phi = (1 + Math.sqrt(5)) / 2; // Golden ratio
const b = Math.log(phi) / (Math.PI / 2); // For golden spiral

// Generate labyrinth with golden ratio pyramids and spirals
const walls = [];
function generateLabyrinth() {
  walls.length = 0;
  // Pyramid structures
  for (let i = 0; i < 5; i++) {
    let base = 50 * phi;
    let height = base / phi;
    let x = 100 + i * 150;
    walls.push({x: x, y: 200, w: base, h: height, type: 'up'}); // Top pyramid (pointing up)
    walls.push({x: x, y: 400 - height, w: base, h: height, type: 'down'}); // Bottom (pointing down)
  }
  // Labyrinth paths
  walls.push({x: 0, y: 0, w: 800, h: 50, type: 'rect'}); // Top wall
  walls.push({x: 0, y: 550, w: 800, h: 50, type: 'rect'}); // Bottom wall
  
  // Add spiral path element
  let cx = 400, cy = 300;
  let a = 10; // Initial radius
  let maxTheta = 4 * Math.PI;
  let spiralWall = {type: 'spiral', cx, cy, a, b, maxTheta, segments: []};
  for (let theta = 0; theta <= maxTheta; theta += 0.2) {
    let r = a * Math.exp(b * theta);
    let x = cx + r * Math.cos(theta);
    let y = cy + r * Math.sin(theta);
    spiralWall.segments.push({x, y, r: 5});
  }
  walls.push(spiralWall);
}

// Draw labyrinth
function drawLabyrinth() {
  ctx.clearRect(0,0,800,600);
  ctx.fillStyle = '#111';
  ctx.fillRect(0,0,800,600);
  ctx.fillStyle = '#444';
  ctx.strokeStyle = '#fff';
  walls.forEach(w => {
    if (w.type === 'rect') {
      ctx.fillRect(w.x, w.y, w.w, w.h);
    } else if (w.type === 'up') {
      ctx.beginPath();
      ctx.moveTo(w.x, w.y + w.h);
      ctx.lineTo(w.x + w.w / 2, w.y);
      ctx.lineTo(w.x + w.w, w.y + w.h);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    } else if (w.type === 'down') {
      ctx.beginPath();
      ctx.moveTo(w.x, w.y);
      ctx.lineTo(w.x + w.w / 2, w.y + w.h);
      ctx.lineTo(w.x + w.w, w.y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    } else if (w.type === 'spiral') {
      ctx.beginPath();
      let theta = 0;
      let r = w.a * Math.exp(w.b * theta);
      let x = w.cx + r * Math.cos(theta);
      let y = w.cy + r * Math.sin(theta);
      ctx.moveTo(x, y);
      for (theta = 0.1; theta <= w.maxTheta; theta += 0.1) {
        r = w.a * Math.exp(w.b * theta);
        x = w.cx + r * Math.cos(theta);
        y = w.cy + r * Math.sin(theta);
        ctx.lineTo(x, y);
      }
      ctx.lineWidth = 3;
      ctx.stroke();
      ctx.lineWidth = 1;
    }
  });
}

// Enhanced fluorescent particle
class Particle {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.color = `hsl(${Math.random()*60+180},100%,50%)`;
    this.alpha = 1;
  }
  update() {
    this.alpha -= 0.01; // Slower fade for better trail
    return this.alpha > 0;
  }
  draw() {
    ctx.shadowColor = this.color;
    ctx.shadowBlur = 15; // Enhanced glow
    ctx.beginPath();
    ctx.arc(this.x, this.y, 5, 0, Math.PI*2);
    ctx.fillStyle = this.color;
    ctx.globalAlpha = this.alpha;
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;
  }
}

// Draw player with glow
function drawPlayer() {
  ctx.shadowColor = 'lime';
  ctx.shadowBlur = 25; // Enhanced
  ctx.beginPath();
  ctx.arc(player.x, player.y, 10, 0, Math.PI*2);
  ctx.fillStyle = 'lime';
  ctx.fill();
  ctx.shadowBlur = 0;
}

// Improved triangle collision detection
function pointInTriangle(px, py, x1, y1, x2, y2, x3, y3) {
  const area = 0.5 * (-y2*x3 + y1*(-x2 + x3) + x1*(y2 - y3) + x2*y3 - x3*y2);
  const s = 1/(2*area)*(y1*x3 - x1*y3 + px*(y3 - y1) + x3*(y1 - py) + x1*(py - y3));
  const t = 1/(2*area)*(x1*y2 - y1*x2 + py*(x1 - x2) + y2*(px - x1) + x2*(y1 - py));
  return s > 0 && t > 0 && (1 - s - t) > 0;
}

function checkCollision(nx, ny) {
  for (let wall of walls) {
    if (wall.type === 'rect') {
      if (nx + 10 > wall.x && nx - 10 < wall.x + wall.w && ny + 10 > wall.y && ny - 10 < wall.y + wall.h) {
        return true;
      }
    } else if (wall.type === 'up') {
      const x1 = wall.x, y1 = wall.y + wall.h;
      const x2 = wall.x + wall.w / 2, y2 = wall.y;
      const x3 = wall.x + wall.w, y3 = wall.y + wall.h;
      if (pointInTriangle(nx, ny, x1, y1, x2, y2, x3, y3)) return true;
    } else if (wall.type === 'down') {
      const x1 = wall.x, y1 = wall.y;
      const x2 = wall.x + wall.w / 2, y2 = wall.y + wall.h;
      const x3 = wall.x + wall.w, y3 = wall.y;
      if (pointInTriangle(nx, ny, x1, y1, x2, y2, x3, y3)) return true;
    } else if (wall.type === 'spiral') {
      for (let seg of wall.segments) {
        let dx = nx - seg.x;
        let dy = ny - seg.y;
        if (Math.sqrt(dx*dx + dy*dy) < 10 + seg.r) return true;
      }
    }
  }
  return false;
}

// Animation loop
function animate() {
  drawLabyrinth();
  drawPlayer();
  particles = particles.filter(p => p.update());
  particles.forEach(p => p.draw());

  // Update player
  let nx = player.x + player.vx;
  let ny = player.y + player.vy;
  if (!checkCollision(nx, ny)) {
    player.x = nx;
    player.y = ny;
  }
  if (Math.abs(player.vx) > 0 || Math.abs(player.vy) > 0) {
    particles.push(new Particle(player.x, player.y)); // Add trail only when moving
  }

  if (player.x > 750) {
    score += 100 * level;
    document.getElementById('score').textContent = `Score: ${score} | Level: ${level}`;
    resetLevel();
  }

  requestAnimationFrame(animate);
}

// Controls
document.addEventListener('keydown', e => {
  switch (e.key) {
    case 'ArrowUp': player.vy = -2; break;
    case 'ArrowDown': player.vy = 2; break;
    case 'ArrowLeft': player.vx = -2; break;
    case 'ArrowRight': player.vx = 2; break;
  }
});
document.addEventListener('keyup', e => {
  switch (e.key) {
    case 'ArrowUp':
    case 'ArrowDown': player.vy = 0; break;
    case 'ArrowLeft':
    case 'ArrowRight': player.vx = 0; break;
  }
});

// Reset for next level
function resetLevel() {
  level++;
  player.x = 50;
  player.y = 300;
  particles = [];
  generateLabyrinth();
}

generateLabyrinth();
animate();
</script>
</body>
</html>
